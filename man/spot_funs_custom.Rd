% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spot-funs.R
\name{spot_funs_custom}
\alias{spot_funs_custom}
\title{Spot Functions Custom}
\usage{
spot_funs_custom(
  pkgs,
  file_path,
  print_pkgs_load_status = FALSE,
  error_if_missing_pkg = FALSE
)
}
\arguments{
\item{pkgs}{Character vector of packages to \code{require} for script. Generally
will be the returned value from \code{spot_pkgs(file_path)}.}

\item{file_path}{character vector of path to file. This function depends on
\code{NCmisc::list.function.in_file()} which requries an actual file_path for a
file passed in.}

\item{print_pkgs_load_status}{Logical, default is \code{FALSE}. If set to \code{TRUE}
will \emph{print} a named vector of logicals showing whether packages are on
machine along with any warning messages that come when running \code{require()}.
Along with output.}

\item{error_if_missing_pkg}{Logical, default is \code{FALSE}. If set to \code{TRUE} then
\code{print_pkgs_load_status = TRUE} automatically. If a package is not
installed on the machine then will print load status of individual pkgs and
result in an error.}
}
\value{
Given default arguments and no missing packages A dataframe with the
following columns is returned: \code{funs}: specifying functions in file.
\code{pkgs}: the package a function came from. If \code{funs} is a custom function or
if it came from a package not installed on your machine, \code{pkgs} will return
"(unknown)". \code{in_multiple_pkgs}: logical, sometimes a function name may
exist in multiple packages loaded. If that is the case then a separate line
will be printed for each loaded package containing the function and
\code{in_multiple_pkgs} will be \code{TRUE} for each. (Ideally this column would not
need to exist and the function could determine which pkg the function is
coming from -- maybe in a future version...)

Note that any unknown pkgs do not show-up in \code{pkgs} but are simply dropped
(any of their functions simply have \code{pkgs} equal to "unknown").
}
\description{
Engine that runs \code{spot_funs()}. \code{spot_funs_custom()} has options for returning
print statements and errors that may be useful when you don't have all
packages installed. It also requires you to provide a character vector for
\code{pkgs} rather than identifying these automatically via \code{spot_pkgs()}.
}
\details{
\code{spot_funs_custom()} is what you should use in cases where you don't trust
\code{spot_pkgs()} to properly identify package dependencies and instead want to
pass in your own character vector of packages.

HOW IT WORKS: Loads packages (\code{pkgs}) in a new R process and then extracts
all functions in specified file via \code{NCmisc::list.functions.in.file()}. The
reason it is necessary to load this in a separate process is it prevents
any packages open in your current session from being used to identify
functions in the source file of interest.

If a package is not included in \code{pkgs}, any functions called that should come
from that package will be assigned to an "(unknown)" value in the returned
output.

Note that any commented out functions or packages in the file are (currently)
included in the output.
}
\examples{
library(funspotr)

file_lines <- "
library(dplyr)
require(tidyr)
library(madeUpPkg)

as_tibble(mpg) \%>\%
  group_by(class) \%>\%
  nest() \%>\%
  mutate(stats = purrr::map(data,
                            ~lm(cty ~ hwy, data = .x)))

made_up_fun()
"

file_output <- tempfile(fileext = ".R")
writeLines(file_lines, file_output)

pkgs <- spot_pkgs(file_output)

# Notice is not able to determine singular package for as_tibble()
spot_funs_custom(pkgs, file_output)

# If you'd rather it error when a pkg doesn't exist (e.g. {madeUpPkg})
# You could run:
# spot_funs_custom(pkgs, file_output, error_if_missing_pkg = TRUE)
}
